// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot_controller_description.proto

#include "robot_controller_description.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace abb {
namespace robot {
constexpr Header::Header(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : options_()
  , ip_address_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , system_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , system_type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , robot_ware_version_(nullptr)
  , rws_port_number_(0u){}
struct HeaderDefaultTypeInternal {
  constexpr HeaderDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~HeaderDefaultTypeInternal() {}
  union {
    Header _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT HeaderDefaultTypeInternal _Header_default_instance_;
constexpr RobotControllerDescription::RobotControllerDescription(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mechanical_units_groups_()
  , rapid_tasks_()
  , header_(nullptr)
  , system_indicators_(nullptr){}
struct RobotControllerDescriptionDefaultTypeInternal {
  constexpr RobotControllerDescriptionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RobotControllerDescriptionDefaultTypeInternal() {}
  union {
    RobotControllerDescription _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RobotControllerDescriptionDefaultTypeInternal _RobotControllerDescription_default_instance_;
constexpr RobotWareVersion::RobotWareVersion(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , major_number_(0u)
  , minor_number_(0u)
  , patch_number_(0u){}
struct RobotWareVersionDefaultTypeInternal {
  constexpr RobotWareVersionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RobotWareVersionDefaultTypeInternal() {}
  union {
    RobotWareVersion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RobotWareVersionDefaultTypeInternal _RobotWareVersion_default_instance_;
constexpr Cartesian::Cartesian(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : x_(0)
  , y_(0)
  , z_(0){}
struct CartesianDefaultTypeInternal {
  constexpr CartesianDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CartesianDefaultTypeInternal() {}
  union {
    Cartesian _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CartesianDefaultTypeInternal _Cartesian_default_instance_;
constexpr Quaternion::Quaternion(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : q1_(0)
  , q2_(0)
  , q3_(0)
  , q4_(0){}
struct QuaternionDefaultTypeInternal {
  constexpr QuaternionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~QuaternionDefaultTypeInternal() {}
  union {
    Quaternion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT QuaternionDefaultTypeInternal _Quaternion_default_instance_;
constexpr Pose::Pose(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : position_(nullptr)
  , rotation_(nullptr){}
struct PoseDefaultTypeInternal {
  constexpr PoseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PoseDefaultTypeInternal() {}
  union {
    Pose _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PoseDefaultTypeInternal _Pose_default_instance_;
constexpr RobotIndicators::RobotIndicators(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : irb14000_(false){}
struct RobotIndicatorsDefaultTypeInternal {
  constexpr RobotIndicatorsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RobotIndicatorsDefaultTypeInternal() {}
  union {
    RobotIndicators _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RobotIndicatorsDefaultTypeInternal _RobotIndicators_default_instance_;
constexpr OptionIndicators::OptionIndicators(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : egm_(false)
  , leadthrough_(false)
  , multimove_(false){}
struct OptionIndicatorsDefaultTypeInternal {
  constexpr OptionIndicatorsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~OptionIndicatorsDefaultTypeInternal() {}
  union {
    OptionIndicators _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OptionIndicatorsDefaultTypeInternal _OptionIndicators_default_instance_;
constexpr AddInIndicators::AddInIndicators(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : smart_gripper_(false)
  , state_machine_1_0_(false)
  , state_machine_1_1_(false){}
struct AddInIndicatorsDefaultTypeInternal {
  constexpr AddInIndicatorsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AddInIndicatorsDefaultTypeInternal() {}
  union {
    AddInIndicators _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AddInIndicatorsDefaultTypeInternal _AddInIndicators_default_instance_;
constexpr SystemIndicators::SystemIndicators(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : robots_(nullptr)
  , options_(nullptr)
  , addins_(nullptr){}
struct SystemIndicatorsDefaultTypeInternal {
  constexpr SystemIndicatorsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SystemIndicatorsDefaultTypeInternal() {}
  union {
    SystemIndicators _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SystemIndicatorsDefaultTypeInternal _SystemIndicators_default_instance_;
constexpr Transmission::Transmission(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , rotating_move_(false){}
struct TransmissionDefaultTypeInternal {
  constexpr TransmissionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TransmissionDefaultTypeInternal() {}
  union {
    Transmission _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TransmissionDefaultTypeInternal _Transmission_default_instance_;
constexpr Arm::Arm(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , lower_joint_bound_(0)
  , upper_joint_bound_(0){}
struct ArmDefaultTypeInternal {
  constexpr ArmDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ArmDefaultTypeInternal() {}
  union {
    Arm _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ArmDefaultTypeInternal _Arm_default_instance_;
constexpr Joint::Joint(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , arm_(nullptr)
  , transmission_(nullptr)
  , logical_axis_(0)
  , kinematic_axis_number_(0){}
struct JointDefaultTypeInternal {
  constexpr JointDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~JointDefaultTypeInternal() {}
  union {
    Joint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT JointDefaultTypeInternal _Joint_default_instance_;
constexpr StandardizedJoint::StandardizedJoint(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : original_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , standardized_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , lower_joint_bound_(0)
  , upper_joint_bound_(0)
  , rotating_move_(false){}
struct StandardizedJointDefaultTypeInternal {
  constexpr StandardizedJointDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StandardizedJointDefaultTypeInternal() {}
  union {
    StandardizedJoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StandardizedJointDefaultTypeInternal _StandardizedJoint_default_instance_;
constexpr Single::Single(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , base_frame_moved_by_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , joint_(nullptr)
  , base_frame_(nullptr){}
struct SingleDefaultTypeInternal {
  constexpr SingleDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SingleDefaultTypeInternal() {}
  union {
    Single _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SingleDefaultTypeInternal _Single_default_instance_;
constexpr Robot::Robot(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : joints_()
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , base_frame_moved_by_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , base_frame_(nullptr){}
struct RobotDefaultTypeInternal {
  constexpr RobotDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RobotDefaultTypeInternal() {}
  union {
    Robot _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RobotDefaultTypeInternal _Robot_default_instance_;
constexpr MechanicalUnit::MechanicalUnit(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : singles_()
  , standardized_joints_()
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , task_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , is_integrated_unit_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , has_integrated_unit_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , status_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , robot_(nullptr)
  , type_(0)

  , axes_(0)
  , axes_total_(0)
  , mode_(0)
{}
struct MechanicalUnitDefaultTypeInternal {
  constexpr MechanicalUnitDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MechanicalUnitDefaultTypeInternal() {}
  union {
    MechanicalUnit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MechanicalUnitDefaultTypeInternal _MechanicalUnit_default_instance_;
constexpr MechanicalUnitGroup::MechanicalUnitGroup(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mechanical_units_()
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , robot_(nullptr){}
struct MechanicalUnitGroupDefaultTypeInternal {
  constexpr MechanicalUnitGroupDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MechanicalUnitGroupDefaultTypeInternal() {}
  union {
    MechanicalUnitGroup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MechanicalUnitGroupDefaultTypeInternal _MechanicalUnitGroup_default_instance_;
constexpr RAPIDModule::RAPIDModule(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct RAPIDModuleDefaultTypeInternal {
  constexpr RAPIDModuleDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RAPIDModuleDefaultTypeInternal() {}
  union {
    RAPIDModule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RAPIDModuleDefaultTypeInternal _RAPIDModule_default_instance_;
constexpr RAPIDTask::RAPIDTask(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : modules_()
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , is_motion_task_(false)
  , is_active_(false)
  , execution_state_(1)
{}
struct RAPIDTaskDefaultTypeInternal {
  constexpr RAPIDTaskDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RAPIDTaskDefaultTypeInternal() {}
  union {
    RAPIDTask _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RAPIDTaskDefaultTypeInternal _RAPIDTask_default_instance_;
}  // namespace robot
}  // namespace abb
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_robot_5fcontroller_5fdescription_2eproto[20];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_robot_5fcontroller_5fdescription_2eproto[3];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_robot_5fcontroller_5fdescription_2eproto = nullptr;

const uint32_t TableStruct_robot_5fcontroller_5fdescription_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::abb::robot::Header, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Header, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::Header, ip_address_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Header, rws_port_number_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Header, robot_ware_version_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Header, system_name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Header, system_type_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Header, options_),
  0,
  4,
  3,
  1,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotControllerDescription, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotControllerDescription, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotControllerDescription, header_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotControllerDescription, system_indicators_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotControllerDescription, mechanical_units_groups_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotControllerDescription, rapid_tasks_),
  0,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotWareVersion, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotWareVersion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotWareVersion, name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotWareVersion, major_number_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotWareVersion, minor_number_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotWareVersion, patch_number_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::abb::robot::Cartesian, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Cartesian, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::Cartesian, x_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Cartesian, y_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Cartesian, z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::robot::Quaternion, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Quaternion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::Quaternion, q1_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Quaternion, q2_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Quaternion, q3_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Quaternion, q4_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::abb::robot::Pose, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Pose, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::Pose, position_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Pose, rotation_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotIndicators, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotIndicators, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotIndicators, irb14000_),
  0,
  PROTOBUF_FIELD_OFFSET(::abb::robot::OptionIndicators, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::OptionIndicators, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::OptionIndicators, egm_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::OptionIndicators, leadthrough_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::OptionIndicators, multimove_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::robot::AddInIndicators, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::AddInIndicators, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::AddInIndicators, smart_gripper_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::AddInIndicators, state_machine_1_0_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::AddInIndicators, state_machine_1_1_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::robot::SystemIndicators, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::SystemIndicators, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::SystemIndicators, robots_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::SystemIndicators, options_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::SystemIndicators, addins_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::robot::Transmission, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Transmission, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::Transmission, name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Transmission, rotating_move_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::abb::robot::Arm, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Arm, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::Arm, name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Arm, lower_joint_bound_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Arm, upper_joint_bound_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::robot::Joint, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Joint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::Joint, name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Joint, logical_axis_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Joint, kinematic_axis_number_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Joint, arm_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Joint, transmission_),
  0,
  3,
  4,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::robot::StandardizedJoint, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::StandardizedJoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::StandardizedJoint, original_name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::StandardizedJoint, standardized_name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::StandardizedJoint, rotating_move_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::StandardizedJoint, lower_joint_bound_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::StandardizedJoint, upper_joint_bound_),
  0,
  1,
  4,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::abb::robot::Single, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Single, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::Single, name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Single, type_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Single, joint_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Single, base_frame_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Single, base_frame_moved_by_),
  0,
  1,
  3,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::robot::Robot, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Robot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::Robot, name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Robot, type_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Robot, joints_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Robot, base_frame_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Robot, base_frame_moved_by_),
  0,
  1,
  ~0u,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, robot_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, singles_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, type_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, task_name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, axes_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, axes_total_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, is_integrated_unit_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, has_integrated_unit_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, status_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, mode_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, standardized_joints_),
  0,
  5,
  ~0u,
  6,
  1,
  7,
  8,
  2,
  3,
  4,
  9,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnitGroup, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnitGroup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnitGroup, name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnitGroup, robot_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnitGroup, mechanical_units_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDModule, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDModule, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDModule, name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDModule, type_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDTask, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDTask, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDTask, name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDTask, is_motion_task_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDTask, is_active_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDTask, execution_state_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDTask, modules_),
  0,
  1,
  2,
  3,
  ~0u,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 12, -1, sizeof(::abb::robot::Header)},
  { 18, 28, -1, sizeof(::abb::robot::RobotControllerDescription)},
  { 32, 42, -1, sizeof(::abb::robot::RobotWareVersion)},
  { 46, 55, -1, sizeof(::abb::robot::Cartesian)},
  { 58, 68, -1, sizeof(::abb::robot::Quaternion)},
  { 72, 80, -1, sizeof(::abb::robot::Pose)},
  { 82, 89, -1, sizeof(::abb::robot::RobotIndicators)},
  { 90, 99, -1, sizeof(::abb::robot::OptionIndicators)},
  { 102, 111, -1, sizeof(::abb::robot::AddInIndicators)},
  { 114, 123, -1, sizeof(::abb::robot::SystemIndicators)},
  { 126, 134, -1, sizeof(::abb::robot::Transmission)},
  { 136, 145, -1, sizeof(::abb::robot::Arm)},
  { 148, 159, -1, sizeof(::abb::robot::Joint)},
  { 164, 175, -1, sizeof(::abb::robot::StandardizedJoint)},
  { 180, 191, -1, sizeof(::abb::robot::Single)},
  { 196, 207, -1, sizeof(::abb::robot::Robot)},
  { 212, 230, -1, sizeof(::abb::robot::MechanicalUnit)},
  { 242, 251, -1, sizeof(::abb::robot::MechanicalUnitGroup)},
  { 254, 262, -1, sizeof(::abb::robot::RAPIDModule)},
  { 264, 275, -1, sizeof(::abb::robot::RAPIDTask)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_Header_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_RobotControllerDescription_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_RobotWareVersion_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_Cartesian_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_Quaternion_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_Pose_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_RobotIndicators_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_OptionIndicators_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_AddInIndicators_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_SystemIndicators_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_Transmission_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_Arm_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_Joint_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_StandardizedJoint_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_Single_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_Robot_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_MechanicalUnit_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_MechanicalUnitGroup_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_RAPIDModule_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::robot::_RAPIDTask_default_instance_),
};

const char descriptor_table_protodef_robot_5fcontroller_5fdescription_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\"robot_controller_description.proto\022\tab"
  "b.robot\"\251\001\n\006Header\022\022\n\nip_address\030\001 \001(\t\022\027"
  "\n\017rws_port_number\030\002 \001(\r\0227\n\022robot_ware_ve"
  "rsion\030\003 \001(\0132\033.abb.robot.RobotWareVersion"
  "\022\023\n\013system_name\030\004 \001(\t\022\023\n\013system_type\030\005 \001"
  "(\t\022\017\n\007options\030\006 \003(\t\"\343\001\n\032RobotControllerD"
  "escription\022!\n\006header\030\001 \001(\0132\021.abb.robot.H"
  "eader\0226\n\021system_indicators\030\002 \001(\0132\033.abb.r"
  "obot.SystemIndicators\022\?\n\027mechanical_unit"
  "s_groups\030\003 \003(\0132\036.abb.robot.MechanicalUni"
  "tGroup\022)\n\013rapid_tasks\030\004 \003(\0132\024.abb.robot."
  "RAPIDTask\"b\n\020RobotWareVersion\022\014\n\004name\030\001 "
  "\001(\t\022\024\n\014major_number\030\002 \001(\r\022\024\n\014minor_numbe"
  "r\030\003 \001(\r\022\024\n\014patch_number\030\004 \001(\r\",\n\tCartesi"
  "an\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 \001(\001\"<\n\nQ"
  "uaternion\022\n\n\002q1\030\001 \001(\001\022\n\n\002q2\030\002 \001(\001\022\n\n\002q3\030"
  "\003 \001(\001\022\n\n\002q4\030\004 \001(\001\"W\n\004Pose\022&\n\010position\030\001 "
  "\001(\0132\024.abb.robot.Cartesian\022\'\n\010rotation\030\002 "
  "\001(\0132\025.abb.robot.Quaternion\"#\n\017RobotIndic"
  "ators\022\020\n\010irb14000\030\001 \001(\010\"G\n\020OptionIndicat"
  "ors\022\013\n\003egm\030\001 \001(\010\022\023\n\013leadthrough\030\002 \001(\010\022\021\n"
  "\tmultimove\030\003 \001(\010\"^\n\017AddInIndicators\022\025\n\rs"
  "mart_gripper\030\001 \001(\010\022\031\n\021state_machine_1_0\030"
  "\002 \001(\010\022\031\n\021state_machine_1_1\030\003 \001(\010\"\230\001\n\020Sys"
  "temIndicators\022*\n\006robots\030\001 \001(\0132\032.abb.robo"
  "t.RobotIndicators\022,\n\007options\030\002 \001(\0132\033.abb"
  ".robot.OptionIndicators\022*\n\006addins\030\003 \001(\0132"
  "\032.abb.robot.AddInIndicators\"3\n\014Transmiss"
  "ion\022\014\n\004name\030\001 \001(\t\022\025\n\rrotating_move\030\002 \001(\010"
  "\"I\n\003Arm\022\014\n\004name\030\001 \001(\t\022\031\n\021lower_joint_bou"
  "nd\030\002 \001(\001\022\031\n\021upper_joint_bound\030\003 \001(\001\"\226\001\n\005"
  "Joint\022\014\n\004name\030\001 \001(\t\022\024\n\014logical_axis\030\002 \001("
  "\005\022\035\n\025kinematic_axis_number\030\003 \001(\005\022\033\n\003arm\030"
  "\004 \001(\0132\016.abb.robot.Arm\022-\n\014transmission\030\005 "
  "\001(\0132\027.abb.robot.Transmission\"\222\001\n\021Standar"
  "dizedJoint\022\025\n\roriginal_name\030\001 \001(\t\022\031\n\021sta"
  "ndardized_name\030\002 \001(\t\022\025\n\rrotating_move\030\003 "
  "\001(\010\022\031\n\021lower_joint_bound\030\004 \001(\001\022\031\n\021upper_"
  "joint_bound\030\005 \001(\001\"\207\001\n\006Single\022\014\n\004name\030\001 \001"
  "(\t\022\014\n\004type\030\002 \001(\t\022\037\n\005joint\030\003 \001(\0132\020.abb.ro"
  "bot.Joint\022#\n\nbase_frame\030\004 \001(\0132\017.abb.robo"
  "t.Pose\022\033\n\023base_frame_moved_by\030\005 \001(\t\"\207\001\n\005"
  "Robot\022\014\n\004name\030\001 \001(\t\022\014\n\004type\030\002 \001(\t\022 \n\006joi"
  "nts\030\003 \003(\0132\020.abb.robot.Joint\022#\n\nbase_fram"
  "e\030\004 \001(\0132\017.abb.robot.Pose\022\033\n\023base_frame_m"
  "oved_by\030\005 \001(\t\"\377\003\n\016MechanicalUnit\022\014\n\004name"
  "\030\001 \001(\t\022\037\n\005robot\030\002 \001(\0132\020.abb.robot.Robot\022"
  "\"\n\007singles\030\003 \003(\0132\021.abb.robot.Single\0227\n\004t"
  "ype\030\004 \001(\0162\036.abb.robot.MechanicalUnit.Typ"
  "e:\tUNDEFINED\022\021\n\ttask_name\030\005 \001(\t\022\014\n\004axes\030"
  "\006 \001(\005\022\022\n\naxes_total\030\007 \001(\005\022\032\n\022is_integrat"
  "ed_unit\030\010 \001(\t\022\033\n\023has_integrated_unit\030\t \001"
  "(\t\022\016\n\006status\030\n \001(\t\0229\n\004mode\030\013 \001(\0162\036.abb.r"
  "obot.MechanicalUnit.Mode:\013DEACTIVATED\0229\n"
  "\023standardized_joints\030\014 \003(\0132\034.abb.robot.S"
  "tandardizedJoint\"E\n\004Type\022\r\n\tUNDEFINED\020\000\022"
  "\010\n\004NONE\020\001\022\r\n\tTCP_ROBOT\020\002\022\t\n\005ROBOT\020\003\022\n\n\006S"
  "INGLE\020\004\"&\n\004Mode\022\017\n\013DEACTIVATED\020\000\022\r\n\tACTI"
  "VATED\020\001\"\202\001\n\023MechanicalUnitGroup\022\014\n\004name\030"
  "\001 \001(\t\022(\n\005robot\030\002 \001(\0132\031.abb.robot.Mechani"
  "calUnit\0223\n\020mechanical_units\030\003 \003(\0132\031.abb."
  "robot.MechanicalUnit\")\n\013RAPIDModule\022\014\n\004n"
  "ame\030\001 \001(\t\022\014\n\004type\030\002 \001(\t\"\213\002\n\tRAPIDTask\022\014\n"
  "\004name\030\001 \001(\t\022\026\n\016is_motion_task\030\002 \001(\010\022\021\n\ti"
  "s_active\030\003 \001(\010\022E\n\017execution_state\030\004 \001(\0162"
  "#.abb.robot.RAPIDTask.ExecutionState:\007UN"
  "KNOWN\022\'\n\007modules\030\005 \003(\0132\026.abb.robot.RAPID"
  "Module\"U\n\016ExecutionState\022\013\n\007UNKNOWN\020\001\022\t\n"
  "\005READY\020\002\022\013\n\007STOPPED\020\003\022\013\n\007STARTED\020\004\022\021\n\rUN"
  "INITIALIZED\020\005"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_robot_5fcontroller_5fdescription_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_robot_5fcontroller_5fdescription_2eproto = {
  false, false, 2773, descriptor_table_protodef_robot_5fcontroller_5fdescription_2eproto, "robot_controller_description.proto", 
  &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once, nullptr, 0, 20,
  schemas, file_default_instances, TableStruct_robot_5fcontroller_5fdescription_2eproto::offsets,
  file_level_metadata_robot_5fcontroller_5fdescription_2eproto, file_level_enum_descriptors_robot_5fcontroller_5fdescription_2eproto, file_level_service_descriptors_robot_5fcontroller_5fdescription_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter() {
  return &descriptor_table_robot_5fcontroller_5fdescription_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_robot_5fcontroller_5fdescription_2eproto(&descriptor_table_robot_5fcontroller_5fdescription_2eproto);
namespace abb {
namespace robot {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MechanicalUnit_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_robot_5fcontroller_5fdescription_2eproto);
  return file_level_enum_descriptors_robot_5fcontroller_5fdescription_2eproto[0];
}
bool MechanicalUnit_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MechanicalUnit_Type MechanicalUnit::UNDEFINED;
constexpr MechanicalUnit_Type MechanicalUnit::NONE;
constexpr MechanicalUnit_Type MechanicalUnit::TCP_ROBOT;
constexpr MechanicalUnit_Type MechanicalUnit::ROBOT;
constexpr MechanicalUnit_Type MechanicalUnit::SINGLE;
constexpr MechanicalUnit_Type MechanicalUnit::Type_MIN;
constexpr MechanicalUnit_Type MechanicalUnit::Type_MAX;
constexpr int MechanicalUnit::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MechanicalUnit_Mode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_robot_5fcontroller_5fdescription_2eproto);
  return file_level_enum_descriptors_robot_5fcontroller_5fdescription_2eproto[1];
}
bool MechanicalUnit_Mode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MechanicalUnit_Mode MechanicalUnit::DEACTIVATED;
constexpr MechanicalUnit_Mode MechanicalUnit::ACTIVATED;
constexpr MechanicalUnit_Mode MechanicalUnit::Mode_MIN;
constexpr MechanicalUnit_Mode MechanicalUnit::Mode_MAX;
constexpr int MechanicalUnit::Mode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RAPIDTask_ExecutionState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_robot_5fcontroller_5fdescription_2eproto);
  return file_level_enum_descriptors_robot_5fcontroller_5fdescription_2eproto[2];
}
bool RAPIDTask_ExecutionState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RAPIDTask_ExecutionState RAPIDTask::UNKNOWN;
constexpr RAPIDTask_ExecutionState RAPIDTask::READY;
constexpr RAPIDTask_ExecutionState RAPIDTask::STOPPED;
constexpr RAPIDTask_ExecutionState RAPIDTask::STARTED;
constexpr RAPIDTask_ExecutionState RAPIDTask::UNINITIALIZED;
constexpr RAPIDTask_ExecutionState RAPIDTask::ExecutionState_MIN;
constexpr RAPIDTask_ExecutionState RAPIDTask::ExecutionState_MAX;
constexpr int RAPIDTask::ExecutionState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Header::_Internal {
 public:
  using HasBits = decltype(std::declval<Header>()._has_bits_);
  static void set_has_ip_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rws_port_number(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::abb::robot::RobotWareVersion& robot_ware_version(const Header* msg);
  static void set_has_robot_ware_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_system_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_system_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::abb::robot::RobotWareVersion&
Header::_Internal::robot_ware_version(const Header* msg) {
  return *msg->robot_ware_version_;
}
Header::Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  options_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.Header)
}
Header::Header(const Header& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      options_(from.options_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ip_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip_address()) {
    ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ip_address(), 
      GetArenaForAllocation());
  }
  system_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    system_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_system_name()) {
    system_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_system_name(), 
      GetArenaForAllocation());
  }
  system_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    system_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_system_type()) {
    system_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_system_type(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_robot_ware_version()) {
    robot_ware_version_ = new ::abb::robot::RobotWareVersion(*from.robot_ware_version_);
  } else {
    robot_ware_version_ = nullptr;
  }
  rws_port_number_ = from.rws_port_number_;
  // @@protoc_insertion_point(copy_constructor:abb.robot.Header)
}

inline void Header::SharedCtor() {
ip_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
system_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  system_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
system_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  system_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&robot_ware_version_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rws_port_number_) -
    reinterpret_cast<char*>(&robot_ware_version_)) + sizeof(rws_port_number_));
}

Header::~Header() {
  // @@protoc_insertion_point(destructor:abb.robot.Header)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Header::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ip_address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  system_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  system_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete robot_ware_version_;
}

void Header::ArenaDtor(void* object) {
  Header* _this = reinterpret_cast< Header* >(object);
  (void)_this;
}
void Header::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Header::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Header::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.Header)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  options_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ip_address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      system_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      system_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(robot_ware_version_ != nullptr);
      robot_ware_version_->Clear();
    }
  }
  rws_port_number_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Header::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string ip_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ip_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.Header.ip_address");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rws_port_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_rws_port_number(&has_bits);
          rws_port_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.RobotWareVersion robot_ware_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_robot_ware_version(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string system_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_system_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.Header.system_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string system_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_system_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.Header.system_type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string options = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_options();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.Header.options");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Header::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.Header)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string ip_address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ip_address().data(), static_cast<int>(this->_internal_ip_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Header.ip_address");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ip_address(), target);
  }

  // optional uint32 rws_port_number = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_rws_port_number(), target);
  }

  // optional .abb.robot.RobotWareVersion robot_ware_version = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::robot_ware_version(this), target, stream);
  }

  // optional string system_name = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_system_name().data(), static_cast<int>(this->_internal_system_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Header.system_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_system_name(), target);
  }

  // optional string system_type = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_system_type().data(), static_cast<int>(this->_internal_system_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Header.system_type");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_system_type(), target);
  }

  // repeated string options = 6;
  for (int i = 0, n = this->_internal_options_size(); i < n; i++) {
    const auto& s = this->_internal_options(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Header.options");
    target = stream->WriteString(6, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.Header)
  return target;
}

size_t Header::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.Header)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string options = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(options_.size());
  for (int i = 0, n = options_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      options_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string ip_address = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ip_address());
    }

    // optional string system_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_system_name());
    }

    // optional string system_type = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_system_type());
    }

    // optional .abb.robot.RobotWareVersion robot_ware_version = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *robot_ware_version_);
    }

    // optional uint32 rws_port_number = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_rws_port_number());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Header::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Header::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Header::GetClassData() const { return &_class_data_; }

void Header::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Header *>(to)->MergeFrom(
      static_cast<const Header &>(from));
}


void Header::MergeFrom(const Header& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.Header)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  options_.MergeFrom(from.options_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ip_address(from._internal_ip_address());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_system_name(from._internal_system_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_system_type(from._internal_system_type());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_robot_ware_version()->::abb::robot::RobotWareVersion::MergeFrom(from._internal_robot_ware_version());
    }
    if (cached_has_bits & 0x00000010u) {
      rws_port_number_ = from.rws_port_number_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Header::CopyFrom(const Header& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.Header)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Header::IsInitialized() const {
  return true;
}

void Header::InternalSwap(Header* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  options_.InternalSwap(&other->options_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ip_address_, lhs_arena,
      &other->ip_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &system_name_, lhs_arena,
      &other->system_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &system_type_, lhs_arena,
      &other->system_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Header, rws_port_number_)
      + sizeof(Header::rws_port_number_)
      - PROTOBUF_FIELD_OFFSET(Header, robot_ware_version_)>(
          reinterpret_cast<char*>(&robot_ware_version_),
          reinterpret_cast<char*>(&other->robot_ware_version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Header::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[0]);
}

// ===================================================================

class RobotControllerDescription::_Internal {
 public:
  using HasBits = decltype(std::declval<RobotControllerDescription>()._has_bits_);
  static const ::abb::robot::Header& header(const RobotControllerDescription* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::robot::SystemIndicators& system_indicators(const RobotControllerDescription* msg);
  static void set_has_system_indicators(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::abb::robot::Header&
RobotControllerDescription::_Internal::header(const RobotControllerDescription* msg) {
  return *msg->header_;
}
const ::abb::robot::SystemIndicators&
RobotControllerDescription::_Internal::system_indicators(const RobotControllerDescription* msg) {
  return *msg->system_indicators_;
}
RobotControllerDescription::RobotControllerDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  mechanical_units_groups_(arena),
  rapid_tasks_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.RobotControllerDescription)
}
RobotControllerDescription::RobotControllerDescription(const RobotControllerDescription& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      mechanical_units_groups_(from.mechanical_units_groups_),
      rapid_tasks_(from.rapid_tasks_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::abb::robot::Header(*from.header_);
  } else {
    header_ = nullptr;
  }
  if (from._internal_has_system_indicators()) {
    system_indicators_ = new ::abb::robot::SystemIndicators(*from.system_indicators_);
  } else {
    system_indicators_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:abb.robot.RobotControllerDescription)
}

inline void RobotControllerDescription::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&header_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&system_indicators_) -
    reinterpret_cast<char*>(&header_)) + sizeof(system_indicators_));
}

RobotControllerDescription::~RobotControllerDescription() {
  // @@protoc_insertion_point(destructor:abb.robot.RobotControllerDescription)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RobotControllerDescription::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete system_indicators_;
}

void RobotControllerDescription::ArenaDtor(void* object) {
  RobotControllerDescription* _this = reinterpret_cast< RobotControllerDescription* >(object);
  (void)_this;
}
void RobotControllerDescription::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RobotControllerDescription::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RobotControllerDescription::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.RobotControllerDescription)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mechanical_units_groups_.Clear();
  rapid_tasks_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(header_ != nullptr);
      header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(system_indicators_ != nullptr);
      system_indicators_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RobotControllerDescription::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .abb.robot.Header header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.SystemIndicators system_indicators = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_system_indicators(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .abb.robot.MechanicalUnitGroup mechanical_units_groups = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_mechanical_units_groups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .abb.robot.RAPIDTask rapid_tasks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_rapid_tasks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RobotControllerDescription::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.RobotControllerDescription)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.robot.Header header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // optional .abb.robot.SystemIndicators system_indicators = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::system_indicators(this), target, stream);
  }

  // repeated .abb.robot.MechanicalUnitGroup mechanical_units_groups = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_mechanical_units_groups_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_mechanical_units_groups(i), target, stream);
  }

  // repeated .abb.robot.RAPIDTask rapid_tasks = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_rapid_tasks_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_rapid_tasks(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.RobotControllerDescription)
  return target;
}

size_t RobotControllerDescription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.RobotControllerDescription)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .abb.robot.MechanicalUnitGroup mechanical_units_groups = 3;
  total_size += 1UL * this->_internal_mechanical_units_groups_size();
  for (const auto& msg : this->mechanical_units_groups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .abb.robot.RAPIDTask rapid_tasks = 4;
  total_size += 1UL * this->_internal_rapid_tasks_size();
  for (const auto& msg : this->rapid_tasks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .abb.robot.Header header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *header_);
    }

    // optional .abb.robot.SystemIndicators system_indicators = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *system_indicators_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RobotControllerDescription::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RobotControllerDescription::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RobotControllerDescription::GetClassData() const { return &_class_data_; }

void RobotControllerDescription::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RobotControllerDescription *>(to)->MergeFrom(
      static_cast<const RobotControllerDescription &>(from));
}


void RobotControllerDescription::MergeFrom(const RobotControllerDescription& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.RobotControllerDescription)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  mechanical_units_groups_.MergeFrom(from.mechanical_units_groups_);
  rapid_tasks_.MergeFrom(from.rapid_tasks_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::abb::robot::Header::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_system_indicators()->::abb::robot::SystemIndicators::MergeFrom(from._internal_system_indicators());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RobotControllerDescription::CopyFrom(const RobotControllerDescription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.RobotControllerDescription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotControllerDescription::IsInitialized() const {
  return true;
}

void RobotControllerDescription::InternalSwap(RobotControllerDescription* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  mechanical_units_groups_.InternalSwap(&other->mechanical_units_groups_);
  rapid_tasks_.InternalSwap(&other->rapid_tasks_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RobotControllerDescription, system_indicators_)
      + sizeof(RobotControllerDescription::system_indicators_)
      - PROTOBUF_FIELD_OFFSET(RobotControllerDescription, header_)>(
          reinterpret_cast<char*>(&header_),
          reinterpret_cast<char*>(&other->header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RobotControllerDescription::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[1]);
}

// ===================================================================

class RobotWareVersion::_Internal {
 public:
  using HasBits = decltype(std::declval<RobotWareVersion>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_major_number(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_minor_number(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_patch_number(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

RobotWareVersion::RobotWareVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.RobotWareVersion)
}
RobotWareVersion::RobotWareVersion(const RobotWareVersion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&major_number_, &from.major_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&patch_number_) -
    reinterpret_cast<char*>(&major_number_)) + sizeof(patch_number_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.RobotWareVersion)
}

inline void RobotWareVersion::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&major_number_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&patch_number_) -
    reinterpret_cast<char*>(&major_number_)) + sizeof(patch_number_));
}

RobotWareVersion::~RobotWareVersion() {
  // @@protoc_insertion_point(destructor:abb.robot.RobotWareVersion)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RobotWareVersion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void RobotWareVersion::ArenaDtor(void* object) {
  RobotWareVersion* _this = reinterpret_cast< RobotWareVersion* >(object);
  (void)_this;
}
void RobotWareVersion::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RobotWareVersion::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RobotWareVersion::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.RobotWareVersion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&major_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&patch_number_) -
        reinterpret_cast<char*>(&major_number_)) + sizeof(patch_number_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RobotWareVersion::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.RobotWareVersion.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 major_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_major_number(&has_bits);
          major_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 minor_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_minor_number(&has_bits);
          minor_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 patch_number = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_patch_number(&has_bits);
          patch_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RobotWareVersion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.RobotWareVersion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.RobotWareVersion.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional uint32 major_number = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_major_number(), target);
  }

  // optional uint32 minor_number = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_minor_number(), target);
  }

  // optional uint32 patch_number = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_patch_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.RobotWareVersion)
  return target;
}

size_t RobotWareVersion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.RobotWareVersion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 major_number = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_major_number());
    }

    // optional uint32 minor_number = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_minor_number());
    }

    // optional uint32 patch_number = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_patch_number());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RobotWareVersion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RobotWareVersion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RobotWareVersion::GetClassData() const { return &_class_data_; }

void RobotWareVersion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RobotWareVersion *>(to)->MergeFrom(
      static_cast<const RobotWareVersion &>(from));
}


void RobotWareVersion::MergeFrom(const RobotWareVersion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.RobotWareVersion)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      major_number_ = from.major_number_;
    }
    if (cached_has_bits & 0x00000004u) {
      minor_number_ = from.minor_number_;
    }
    if (cached_has_bits & 0x00000008u) {
      patch_number_ = from.patch_number_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RobotWareVersion::CopyFrom(const RobotWareVersion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.RobotWareVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotWareVersion::IsInitialized() const {
  return true;
}

void RobotWareVersion::InternalSwap(RobotWareVersion* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RobotWareVersion, patch_number_)
      + sizeof(RobotWareVersion::patch_number_)
      - PROTOBUF_FIELD_OFFSET(RobotWareVersion, major_number_)>(
          reinterpret_cast<char*>(&major_number_),
          reinterpret_cast<char*>(&other->major_number_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RobotWareVersion::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[2]);
}

// ===================================================================

class Cartesian::_Internal {
 public:
  using HasBits = decltype(std::declval<Cartesian>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Cartesian::Cartesian(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.Cartesian)
}
Cartesian::Cartesian(const Cartesian& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.Cartesian)
}

inline void Cartesian::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

Cartesian::~Cartesian() {
  // @@protoc_insertion_point(destructor:abb.robot.Cartesian)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Cartesian::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Cartesian::ArenaDtor(void* object) {
  Cartesian* _this = reinterpret_cast< Cartesian* >(object);
  (void)_this;
}
void Cartesian::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Cartesian::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Cartesian::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.Cartesian)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Cartesian::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_z(&has_bits);
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Cartesian::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.Cartesian)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // optional double z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.Cartesian)
  return target;
}

size_t Cartesian::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.Cartesian)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Cartesian::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Cartesian::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Cartesian::GetClassData() const { return &_class_data_; }

void Cartesian::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Cartesian *>(to)->MergeFrom(
      static_cast<const Cartesian &>(from));
}


void Cartesian::MergeFrom(const Cartesian& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.Cartesian)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Cartesian::CopyFrom(const Cartesian& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.Cartesian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Cartesian::IsInitialized() const {
  return true;
}

void Cartesian::InternalSwap(Cartesian* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Cartesian, z_)
      + sizeof(Cartesian::z_)
      - PROTOBUF_FIELD_OFFSET(Cartesian, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Cartesian::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[3]);
}

// ===================================================================

class Quaternion::_Internal {
 public:
  using HasBits = decltype(std::declval<Quaternion>()._has_bits_);
  static void set_has_q1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_q2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_q3(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_q4(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Quaternion::Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.Quaternion)
}
Quaternion::Quaternion(const Quaternion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&q1_, &from.q1_,
    static_cast<size_t>(reinterpret_cast<char*>(&q4_) -
    reinterpret_cast<char*>(&q1_)) + sizeof(q4_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.Quaternion)
}

inline void Quaternion::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&q1_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&q4_) -
    reinterpret_cast<char*>(&q1_)) + sizeof(q4_));
}

Quaternion::~Quaternion() {
  // @@protoc_insertion_point(destructor:abb.robot.Quaternion)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Quaternion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Quaternion::ArenaDtor(void* object) {
  Quaternion* _this = reinterpret_cast< Quaternion* >(object);
  (void)_this;
}
void Quaternion::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Quaternion::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Quaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.Quaternion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&q1_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&q4_) -
        reinterpret_cast<char*>(&q1_)) + sizeof(q4_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Quaternion::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double q1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_q1(&has_bits);
          q1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double q2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_q2(&has_bits);
          q2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double q3 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_q3(&has_bits);
          q3_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double q4 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_q4(&has_bits);
          q4_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Quaternion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.Quaternion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double q1 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_q1(), target);
  }

  // optional double q2 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_q2(), target);
  }

  // optional double q3 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_q3(), target);
  }

  // optional double q4 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_q4(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.Quaternion)
  return target;
}

size_t Quaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.Quaternion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional double q1 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double q2 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double q3 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double q4 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Quaternion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Quaternion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Quaternion::GetClassData() const { return &_class_data_; }

void Quaternion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Quaternion *>(to)->MergeFrom(
      static_cast<const Quaternion &>(from));
}


void Quaternion::MergeFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.Quaternion)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      q1_ = from.q1_;
    }
    if (cached_has_bits & 0x00000002u) {
      q2_ = from.q2_;
    }
    if (cached_has_bits & 0x00000004u) {
      q3_ = from.q3_;
    }
    if (cached_has_bits & 0x00000008u) {
      q4_ = from.q4_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Quaternion::CopyFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Quaternion::IsInitialized() const {
  return true;
}

void Quaternion::InternalSwap(Quaternion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Quaternion, q4_)
      + sizeof(Quaternion::q4_)
      - PROTOBUF_FIELD_OFFSET(Quaternion, q1_)>(
          reinterpret_cast<char*>(&q1_),
          reinterpret_cast<char*>(&other->q1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Quaternion::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[4]);
}

// ===================================================================

class Pose::_Internal {
 public:
  using HasBits = decltype(std::declval<Pose>()._has_bits_);
  static const ::abb::robot::Cartesian& position(const Pose* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::robot::Quaternion& rotation(const Pose* msg);
  static void set_has_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::abb::robot::Cartesian&
Pose::_Internal::position(const Pose* msg) {
  return *msg->position_;
}
const ::abb::robot::Quaternion&
Pose::_Internal::rotation(const Pose* msg) {
  return *msg->rotation_;
}
Pose::Pose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.Pose)
}
Pose::Pose(const Pose& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    position_ = new ::abb::robot::Cartesian(*from.position_);
  } else {
    position_ = nullptr;
  }
  if (from._internal_has_rotation()) {
    rotation_ = new ::abb::robot::Quaternion(*from.rotation_);
  } else {
    rotation_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:abb.robot.Pose)
}

inline void Pose::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&position_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rotation_) -
    reinterpret_cast<char*>(&position_)) + sizeof(rotation_));
}

Pose::~Pose() {
  // @@protoc_insertion_point(destructor:abb.robot.Pose)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Pose::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete position_;
  if (this != internal_default_instance()) delete rotation_;
}

void Pose::ArenaDtor(void* object) {
  Pose* _this = reinterpret_cast< Pose* >(object);
  (void)_this;
}
void Pose::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Pose::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Pose::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.Pose)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(position_ != nullptr);
      position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(rotation_ != nullptr);
      rotation_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Pose::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .abb.robot.Cartesian position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.Quaternion rotation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Pose::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.Pose)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.robot.Cartesian position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::position(this), target, stream);
  }

  // optional .abb.robot.Quaternion rotation = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::rotation(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.Pose)
  return target;
}

size_t Pose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.Pose)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .abb.robot.Cartesian position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *position_);
    }

    // optional .abb.robot.Quaternion rotation = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rotation_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Pose::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Pose::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Pose::GetClassData() const { return &_class_data_; }

void Pose::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Pose *>(to)->MergeFrom(
      static_cast<const Pose &>(from));
}


void Pose::MergeFrom(const Pose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.Pose)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_position()->::abb::robot::Cartesian::MergeFrom(from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_rotation()->::abb::robot::Quaternion::MergeFrom(from._internal_rotation());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Pose::CopyFrom(const Pose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.Pose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pose::IsInitialized() const {
  return true;
}

void Pose::InternalSwap(Pose* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Pose, rotation_)
      + sizeof(Pose::rotation_)
      - PROTOBUF_FIELD_OFFSET(Pose, position_)>(
          reinterpret_cast<char*>(&position_),
          reinterpret_cast<char*>(&other->position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Pose::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[5]);
}

// ===================================================================

class RobotIndicators::_Internal {
 public:
  using HasBits = decltype(std::declval<RobotIndicators>()._has_bits_);
  static void set_has_irb14000(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RobotIndicators::RobotIndicators(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.RobotIndicators)
}
RobotIndicators::RobotIndicators(const RobotIndicators& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  irb14000_ = from.irb14000_;
  // @@protoc_insertion_point(copy_constructor:abb.robot.RobotIndicators)
}

inline void RobotIndicators::SharedCtor() {
irb14000_ = false;
}

RobotIndicators::~RobotIndicators() {
  // @@protoc_insertion_point(destructor:abb.robot.RobotIndicators)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RobotIndicators::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RobotIndicators::ArenaDtor(void* object) {
  RobotIndicators* _this = reinterpret_cast< RobotIndicators* >(object);
  (void)_this;
}
void RobotIndicators::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RobotIndicators::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RobotIndicators::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.RobotIndicators)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  irb14000_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RobotIndicators::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool irb14000 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_irb14000(&has_bits);
          irb14000_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RobotIndicators::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.RobotIndicators)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool irb14000 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_irb14000(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.RobotIndicators)
  return target;
}

size_t RobotIndicators::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.RobotIndicators)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool irb14000 = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RobotIndicators::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RobotIndicators::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RobotIndicators::GetClassData() const { return &_class_data_; }

void RobotIndicators::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RobotIndicators *>(to)->MergeFrom(
      static_cast<const RobotIndicators &>(from));
}


void RobotIndicators::MergeFrom(const RobotIndicators& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.RobotIndicators)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_irb14000()) {
    _internal_set_irb14000(from._internal_irb14000());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RobotIndicators::CopyFrom(const RobotIndicators& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.RobotIndicators)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotIndicators::IsInitialized() const {
  return true;
}

void RobotIndicators::InternalSwap(RobotIndicators* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(irb14000_, other->irb14000_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RobotIndicators::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[6]);
}

// ===================================================================

class OptionIndicators::_Internal {
 public:
  using HasBits = decltype(std::declval<OptionIndicators>()._has_bits_);
  static void set_has_egm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_leadthrough(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_multimove(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

OptionIndicators::OptionIndicators(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.OptionIndicators)
}
OptionIndicators::OptionIndicators(const OptionIndicators& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&egm_, &from.egm_,
    static_cast<size_t>(reinterpret_cast<char*>(&multimove_) -
    reinterpret_cast<char*>(&egm_)) + sizeof(multimove_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.OptionIndicators)
}

inline void OptionIndicators::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&egm_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&multimove_) -
    reinterpret_cast<char*>(&egm_)) + sizeof(multimove_));
}

OptionIndicators::~OptionIndicators() {
  // @@protoc_insertion_point(destructor:abb.robot.OptionIndicators)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void OptionIndicators::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void OptionIndicators::ArenaDtor(void* object) {
  OptionIndicators* _this = reinterpret_cast< OptionIndicators* >(object);
  (void)_this;
}
void OptionIndicators::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void OptionIndicators::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OptionIndicators::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.OptionIndicators)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&egm_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&multimove_) -
      reinterpret_cast<char*>(&egm_)) + sizeof(multimove_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OptionIndicators::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool egm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_egm(&has_bits);
          egm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool leadthrough = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_leadthrough(&has_bits);
          leadthrough_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool multimove = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_multimove(&has_bits);
          multimove_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OptionIndicators::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.OptionIndicators)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool egm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_egm(), target);
  }

  // optional bool leadthrough = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_leadthrough(), target);
  }

  // optional bool multimove = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_multimove(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.OptionIndicators)
  return target;
}

size_t OptionIndicators::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.OptionIndicators)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool egm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool leadthrough = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool multimove = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OptionIndicators::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    OptionIndicators::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OptionIndicators::GetClassData() const { return &_class_data_; }

void OptionIndicators::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<OptionIndicators *>(to)->MergeFrom(
      static_cast<const OptionIndicators &>(from));
}


void OptionIndicators::MergeFrom(const OptionIndicators& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.OptionIndicators)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      egm_ = from.egm_;
    }
    if (cached_has_bits & 0x00000002u) {
      leadthrough_ = from.leadthrough_;
    }
    if (cached_has_bits & 0x00000004u) {
      multimove_ = from.multimove_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OptionIndicators::CopyFrom(const OptionIndicators& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.OptionIndicators)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OptionIndicators::IsInitialized() const {
  return true;
}

void OptionIndicators::InternalSwap(OptionIndicators* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OptionIndicators, multimove_)
      + sizeof(OptionIndicators::multimove_)
      - PROTOBUF_FIELD_OFFSET(OptionIndicators, egm_)>(
          reinterpret_cast<char*>(&egm_),
          reinterpret_cast<char*>(&other->egm_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OptionIndicators::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[7]);
}

// ===================================================================

class AddInIndicators::_Internal {
 public:
  using HasBits = decltype(std::declval<AddInIndicators>()._has_bits_);
  static void set_has_smart_gripper(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_state_machine_1_0(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_state_machine_1_1(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

AddInIndicators::AddInIndicators(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.AddInIndicators)
}
AddInIndicators::AddInIndicators(const AddInIndicators& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&smart_gripper_, &from.smart_gripper_,
    static_cast<size_t>(reinterpret_cast<char*>(&state_machine_1_1_) -
    reinterpret_cast<char*>(&smart_gripper_)) + sizeof(state_machine_1_1_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.AddInIndicators)
}

inline void AddInIndicators::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&smart_gripper_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&state_machine_1_1_) -
    reinterpret_cast<char*>(&smart_gripper_)) + sizeof(state_machine_1_1_));
}

AddInIndicators::~AddInIndicators() {
  // @@protoc_insertion_point(destructor:abb.robot.AddInIndicators)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AddInIndicators::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AddInIndicators::ArenaDtor(void* object) {
  AddInIndicators* _this = reinterpret_cast< AddInIndicators* >(object);
  (void)_this;
}
void AddInIndicators::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AddInIndicators::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AddInIndicators::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.AddInIndicators)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&smart_gripper_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&state_machine_1_1_) -
      reinterpret_cast<char*>(&smart_gripper_)) + sizeof(state_machine_1_1_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddInIndicators::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool smart_gripper = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_smart_gripper(&has_bits);
          smart_gripper_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool state_machine_1_0 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_state_machine_1_0(&has_bits);
          state_machine_1_0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool state_machine_1_1 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_state_machine_1_1(&has_bits);
          state_machine_1_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AddInIndicators::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.AddInIndicators)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool smart_gripper = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_smart_gripper(), target);
  }

  // optional bool state_machine_1_0 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_state_machine_1_0(), target);
  }

  // optional bool state_machine_1_1 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_state_machine_1_1(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.AddInIndicators)
  return target;
}

size_t AddInIndicators::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.AddInIndicators)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool smart_gripper = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool state_machine_1_0 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool state_machine_1_1 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddInIndicators::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AddInIndicators::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddInIndicators::GetClassData() const { return &_class_data_; }

void AddInIndicators::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AddInIndicators *>(to)->MergeFrom(
      static_cast<const AddInIndicators &>(from));
}


void AddInIndicators::MergeFrom(const AddInIndicators& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.AddInIndicators)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      smart_gripper_ = from.smart_gripper_;
    }
    if (cached_has_bits & 0x00000002u) {
      state_machine_1_0_ = from.state_machine_1_0_;
    }
    if (cached_has_bits & 0x00000004u) {
      state_machine_1_1_ = from.state_machine_1_1_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddInIndicators::CopyFrom(const AddInIndicators& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.AddInIndicators)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddInIndicators::IsInitialized() const {
  return true;
}

void AddInIndicators::InternalSwap(AddInIndicators* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddInIndicators, state_machine_1_1_)
      + sizeof(AddInIndicators::state_machine_1_1_)
      - PROTOBUF_FIELD_OFFSET(AddInIndicators, smart_gripper_)>(
          reinterpret_cast<char*>(&smart_gripper_),
          reinterpret_cast<char*>(&other->smart_gripper_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddInIndicators::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[8]);
}

// ===================================================================

class SystemIndicators::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemIndicators>()._has_bits_);
  static const ::abb::robot::RobotIndicators& robots(const SystemIndicators* msg);
  static void set_has_robots(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::robot::OptionIndicators& options(const SystemIndicators* msg);
  static void set_has_options(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::robot::AddInIndicators& addins(const SystemIndicators* msg);
  static void set_has_addins(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::abb::robot::RobotIndicators&
SystemIndicators::_Internal::robots(const SystemIndicators* msg) {
  return *msg->robots_;
}
const ::abb::robot::OptionIndicators&
SystemIndicators::_Internal::options(const SystemIndicators* msg) {
  return *msg->options_;
}
const ::abb::robot::AddInIndicators&
SystemIndicators::_Internal::addins(const SystemIndicators* msg) {
  return *msg->addins_;
}
SystemIndicators::SystemIndicators(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.SystemIndicators)
}
SystemIndicators::SystemIndicators(const SystemIndicators& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_robots()) {
    robots_ = new ::abb::robot::RobotIndicators(*from.robots_);
  } else {
    robots_ = nullptr;
  }
  if (from._internal_has_options()) {
    options_ = new ::abb::robot::OptionIndicators(*from.options_);
  } else {
    options_ = nullptr;
  }
  if (from._internal_has_addins()) {
    addins_ = new ::abb::robot::AddInIndicators(*from.addins_);
  } else {
    addins_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:abb.robot.SystemIndicators)
}

inline void SystemIndicators::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&robots_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&addins_) -
    reinterpret_cast<char*>(&robots_)) + sizeof(addins_));
}

SystemIndicators::~SystemIndicators() {
  // @@protoc_insertion_point(destructor:abb.robot.SystemIndicators)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SystemIndicators::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete robots_;
  if (this != internal_default_instance()) delete options_;
  if (this != internal_default_instance()) delete addins_;
}

void SystemIndicators::ArenaDtor(void* object) {
  SystemIndicators* _this = reinterpret_cast< SystemIndicators* >(object);
  (void)_this;
}
void SystemIndicators::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SystemIndicators::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemIndicators::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.SystemIndicators)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(robots_ != nullptr);
      robots_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(options_ != nullptr);
      options_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(addins_ != nullptr);
      addins_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SystemIndicators::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .abb.robot.RobotIndicators robots = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_robots(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.OptionIndicators options = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.AddInIndicators addins = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_addins(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemIndicators::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.SystemIndicators)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.robot.RobotIndicators robots = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::robots(this), target, stream);
  }

  // optional .abb.robot.OptionIndicators options = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::options(this), target, stream);
  }

  // optional .abb.robot.AddInIndicators addins = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::addins(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.SystemIndicators)
  return target;
}

size_t SystemIndicators::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.SystemIndicators)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .abb.robot.RobotIndicators robots = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *robots_);
    }

    // optional .abb.robot.OptionIndicators options = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *options_);
    }

    // optional .abb.robot.AddInIndicators addins = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *addins_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SystemIndicators::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SystemIndicators::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SystemIndicators::GetClassData() const { return &_class_data_; }

void SystemIndicators::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SystemIndicators *>(to)->MergeFrom(
      static_cast<const SystemIndicators &>(from));
}


void SystemIndicators::MergeFrom(const SystemIndicators& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.SystemIndicators)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_robots()->::abb::robot::RobotIndicators::MergeFrom(from._internal_robots());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_options()->::abb::robot::OptionIndicators::MergeFrom(from._internal_options());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_addins()->::abb::robot::AddInIndicators::MergeFrom(from._internal_addins());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SystemIndicators::CopyFrom(const SystemIndicators& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.SystemIndicators)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemIndicators::IsInitialized() const {
  return true;
}

void SystemIndicators::InternalSwap(SystemIndicators* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemIndicators, addins_)
      + sizeof(SystemIndicators::addins_)
      - PROTOBUF_FIELD_OFFSET(SystemIndicators, robots_)>(
          reinterpret_cast<char*>(&robots_),
          reinterpret_cast<char*>(&other->robots_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SystemIndicators::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[9]);
}

// ===================================================================

class Transmission::_Internal {
 public:
  using HasBits = decltype(std::declval<Transmission>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rotating_move(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Transmission::Transmission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.Transmission)
}
Transmission::Transmission(const Transmission& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  rotating_move_ = from.rotating_move_;
  // @@protoc_insertion_point(copy_constructor:abb.robot.Transmission)
}

inline void Transmission::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
rotating_move_ = false;
}

Transmission::~Transmission() {
  // @@protoc_insertion_point(destructor:abb.robot.Transmission)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Transmission::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Transmission::ArenaDtor(void* object) {
  Transmission* _this = reinterpret_cast< Transmission* >(object);
  (void)_this;
}
void Transmission::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Transmission::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Transmission::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.Transmission)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  rotating_move_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Transmission::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.Transmission.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool rotating_move = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_rotating_move(&has_bits);
          rotating_move_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Transmission::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.Transmission)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Transmission.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bool rotating_move = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_rotating_move(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.Transmission)
  return target;
}

size_t Transmission::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.Transmission)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional bool rotating_move = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Transmission::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Transmission::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Transmission::GetClassData() const { return &_class_data_; }

void Transmission::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Transmission *>(to)->MergeFrom(
      static_cast<const Transmission &>(from));
}


void Transmission::MergeFrom(const Transmission& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.Transmission)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      rotating_move_ = from.rotating_move_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Transmission::CopyFrom(const Transmission& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.Transmission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Transmission::IsInitialized() const {
  return true;
}

void Transmission::InternalSwap(Transmission* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(rotating_move_, other->rotating_move_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Transmission::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[10]);
}

// ===================================================================

class Arm::_Internal {
 public:
  using HasBits = decltype(std::declval<Arm>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lower_joint_bound(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_upper_joint_bound(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Arm::Arm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.Arm)
}
Arm::Arm(const Arm& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&lower_joint_bound_, &from.lower_joint_bound_,
    static_cast<size_t>(reinterpret_cast<char*>(&upper_joint_bound_) -
    reinterpret_cast<char*>(&lower_joint_bound_)) + sizeof(upper_joint_bound_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.Arm)
}

inline void Arm::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&lower_joint_bound_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&upper_joint_bound_) -
    reinterpret_cast<char*>(&lower_joint_bound_)) + sizeof(upper_joint_bound_));
}

Arm::~Arm() {
  // @@protoc_insertion_point(destructor:abb.robot.Arm)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Arm::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Arm::ArenaDtor(void* object) {
  Arm* _this = reinterpret_cast< Arm* >(object);
  (void)_this;
}
void Arm::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Arm::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Arm::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.Arm)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&lower_joint_bound_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&upper_joint_bound_) -
        reinterpret_cast<char*>(&lower_joint_bound_)) + sizeof(upper_joint_bound_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Arm::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.Arm.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double lower_joint_bound = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_lower_joint_bound(&has_bits);
          lower_joint_bound_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double upper_joint_bound = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_upper_joint_bound(&has_bits);
          upper_joint_bound_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Arm::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.Arm)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Arm.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional double lower_joint_bound = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_lower_joint_bound(), target);
  }

  // optional double upper_joint_bound = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_upper_joint_bound(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.Arm)
  return target;
}

size_t Arm::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.Arm)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional double lower_joint_bound = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double upper_joint_bound = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Arm::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Arm::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Arm::GetClassData() const { return &_class_data_; }

void Arm::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Arm *>(to)->MergeFrom(
      static_cast<const Arm &>(from));
}


void Arm::MergeFrom(const Arm& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.Arm)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      lower_joint_bound_ = from.lower_joint_bound_;
    }
    if (cached_has_bits & 0x00000004u) {
      upper_joint_bound_ = from.upper_joint_bound_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Arm::CopyFrom(const Arm& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.Arm)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Arm::IsInitialized() const {
  return true;
}

void Arm::InternalSwap(Arm* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Arm, upper_joint_bound_)
      + sizeof(Arm::upper_joint_bound_)
      - PROTOBUF_FIELD_OFFSET(Arm, lower_joint_bound_)>(
          reinterpret_cast<char*>(&lower_joint_bound_),
          reinterpret_cast<char*>(&other->lower_joint_bound_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Arm::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[11]);
}

// ===================================================================

class Joint::_Internal {
 public:
  using HasBits = decltype(std::declval<Joint>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_logical_axis(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_kinematic_axis_number(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::abb::robot::Arm& arm(const Joint* msg);
  static void set_has_arm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::robot::Transmission& transmission(const Joint* msg);
  static void set_has_transmission(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::abb::robot::Arm&
Joint::_Internal::arm(const Joint* msg) {
  return *msg->arm_;
}
const ::abb::robot::Transmission&
Joint::_Internal::transmission(const Joint* msg) {
  return *msg->transmission_;
}
Joint::Joint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.Joint)
}
Joint::Joint(const Joint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_arm()) {
    arm_ = new ::abb::robot::Arm(*from.arm_);
  } else {
    arm_ = nullptr;
  }
  if (from._internal_has_transmission()) {
    transmission_ = new ::abb::robot::Transmission(*from.transmission_);
  } else {
    transmission_ = nullptr;
  }
  ::memcpy(&logical_axis_, &from.logical_axis_,
    static_cast<size_t>(reinterpret_cast<char*>(&kinematic_axis_number_) -
    reinterpret_cast<char*>(&logical_axis_)) + sizeof(kinematic_axis_number_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.Joint)
}

inline void Joint::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&arm_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&kinematic_axis_number_) -
    reinterpret_cast<char*>(&arm_)) + sizeof(kinematic_axis_number_));
}

Joint::~Joint() {
  // @@protoc_insertion_point(destructor:abb.robot.Joint)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Joint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete arm_;
  if (this != internal_default_instance()) delete transmission_;
}

void Joint::ArenaDtor(void* object) {
  Joint* _this = reinterpret_cast< Joint* >(object);
  (void)_this;
}
void Joint::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Joint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Joint::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.Joint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(arm_ != nullptr);
      arm_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(transmission_ != nullptr);
      transmission_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&logical_axis_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&kinematic_axis_number_) -
        reinterpret_cast<char*>(&logical_axis_)) + sizeof(kinematic_axis_number_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Joint::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.Joint.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 logical_axis = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_logical_axis(&has_bits);
          logical_axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 kinematic_axis_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_kinematic_axis_number(&has_bits);
          kinematic_axis_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.Arm arm = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_arm(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.Transmission transmission = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_transmission(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Joint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.Joint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Joint.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional int32 logical_axis = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_logical_axis(), target);
  }

  // optional int32 kinematic_axis_number = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_kinematic_axis_number(), target);
  }

  // optional .abb.robot.Arm arm = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::arm(this), target, stream);
  }

  // optional .abb.robot.Transmission transmission = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::transmission(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.Joint)
  return target;
}

size_t Joint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.Joint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .abb.robot.Arm arm = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *arm_);
    }

    // optional .abb.robot.Transmission transmission = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *transmission_);
    }

    // optional int32 logical_axis = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_logical_axis());
    }

    // optional int32 kinematic_axis_number = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_kinematic_axis_number());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Joint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Joint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Joint::GetClassData() const { return &_class_data_; }

void Joint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Joint *>(to)->MergeFrom(
      static_cast<const Joint &>(from));
}


void Joint::MergeFrom(const Joint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.Joint)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_arm()->::abb::robot::Arm::MergeFrom(from._internal_arm());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_transmission()->::abb::robot::Transmission::MergeFrom(from._internal_transmission());
    }
    if (cached_has_bits & 0x00000008u) {
      logical_axis_ = from.logical_axis_;
    }
    if (cached_has_bits & 0x00000010u) {
      kinematic_axis_number_ = from.kinematic_axis_number_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Joint::CopyFrom(const Joint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.Joint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Joint::IsInitialized() const {
  return true;
}

void Joint::InternalSwap(Joint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Joint, kinematic_axis_number_)
      + sizeof(Joint::kinematic_axis_number_)
      - PROTOBUF_FIELD_OFFSET(Joint, arm_)>(
          reinterpret_cast<char*>(&arm_),
          reinterpret_cast<char*>(&other->arm_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Joint::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[12]);
}

// ===================================================================

class StandardizedJoint::_Internal {
 public:
  using HasBits = decltype(std::declval<StandardizedJoint>()._has_bits_);
  static void set_has_original_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_standardized_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rotating_move(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_lower_joint_bound(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_upper_joint_bound(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

StandardizedJoint::StandardizedJoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.StandardizedJoint)
}
StandardizedJoint::StandardizedJoint(const StandardizedJoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  original_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    original_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_original_name()) {
    original_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_original_name(), 
      GetArenaForAllocation());
  }
  standardized_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    standardized_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_standardized_name()) {
    standardized_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_standardized_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&lower_joint_bound_, &from.lower_joint_bound_,
    static_cast<size_t>(reinterpret_cast<char*>(&rotating_move_) -
    reinterpret_cast<char*>(&lower_joint_bound_)) + sizeof(rotating_move_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.StandardizedJoint)
}

inline void StandardizedJoint::SharedCtor() {
original_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  original_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
standardized_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  standardized_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&lower_joint_bound_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rotating_move_) -
    reinterpret_cast<char*>(&lower_joint_bound_)) + sizeof(rotating_move_));
}

StandardizedJoint::~StandardizedJoint() {
  // @@protoc_insertion_point(destructor:abb.robot.StandardizedJoint)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StandardizedJoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  original_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  standardized_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StandardizedJoint::ArenaDtor(void* object) {
  StandardizedJoint* _this = reinterpret_cast< StandardizedJoint* >(object);
  (void)_this;
}
void StandardizedJoint::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StandardizedJoint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StandardizedJoint::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.StandardizedJoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      original_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      standardized_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&lower_joint_bound_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rotating_move_) -
        reinterpret_cast<char*>(&lower_joint_bound_)) + sizeof(rotating_move_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StandardizedJoint::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string original_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_original_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.StandardizedJoint.original_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string standardized_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_standardized_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.StandardizedJoint.standardized_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool rotating_move = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_rotating_move(&has_bits);
          rotating_move_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double lower_joint_bound = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_lower_joint_bound(&has_bits);
          lower_joint_bound_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double upper_joint_bound = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_upper_joint_bound(&has_bits);
          upper_joint_bound_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StandardizedJoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.StandardizedJoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string original_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_original_name().data(), static_cast<int>(this->_internal_original_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.StandardizedJoint.original_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_original_name(), target);
  }

  // optional string standardized_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_standardized_name().data(), static_cast<int>(this->_internal_standardized_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.StandardizedJoint.standardized_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_standardized_name(), target);
  }

  // optional bool rotating_move = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_rotating_move(), target);
  }

  // optional double lower_joint_bound = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_lower_joint_bound(), target);
  }

  // optional double upper_joint_bound = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_upper_joint_bound(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.StandardizedJoint)
  return target;
}

size_t StandardizedJoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.StandardizedJoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string original_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_original_name());
    }

    // optional string standardized_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_standardized_name());
    }

    // optional double lower_joint_bound = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double upper_joint_bound = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional bool rotating_move = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StandardizedJoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StandardizedJoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StandardizedJoint::GetClassData() const { return &_class_data_; }

void StandardizedJoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StandardizedJoint *>(to)->MergeFrom(
      static_cast<const StandardizedJoint &>(from));
}


void StandardizedJoint::MergeFrom(const StandardizedJoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.StandardizedJoint)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_original_name(from._internal_original_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_standardized_name(from._internal_standardized_name());
    }
    if (cached_has_bits & 0x00000004u) {
      lower_joint_bound_ = from.lower_joint_bound_;
    }
    if (cached_has_bits & 0x00000008u) {
      upper_joint_bound_ = from.upper_joint_bound_;
    }
    if (cached_has_bits & 0x00000010u) {
      rotating_move_ = from.rotating_move_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StandardizedJoint::CopyFrom(const StandardizedJoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.StandardizedJoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StandardizedJoint::IsInitialized() const {
  return true;
}

void StandardizedJoint::InternalSwap(StandardizedJoint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &original_name_, lhs_arena,
      &other->original_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &standardized_name_, lhs_arena,
      &other->standardized_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StandardizedJoint, rotating_move_)
      + sizeof(StandardizedJoint::rotating_move_)
      - PROTOBUF_FIELD_OFFSET(StandardizedJoint, lower_joint_bound_)>(
          reinterpret_cast<char*>(&lower_joint_bound_),
          reinterpret_cast<char*>(&other->lower_joint_bound_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StandardizedJoint::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[13]);
}

// ===================================================================

class Single::_Internal {
 public:
  using HasBits = decltype(std::declval<Single>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::robot::Joint& joint(const Single* msg);
  static void set_has_joint(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::abb::robot::Pose& base_frame(const Single* msg);
  static void set_has_base_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_base_frame_moved_by(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::abb::robot::Joint&
Single::_Internal::joint(const Single* msg) {
  return *msg->joint_;
}
const ::abb::robot::Pose&
Single::_Internal::base_frame(const Single* msg) {
  return *msg->base_frame_;
}
Single::Single(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.Single)
}
Single::Single(const Single& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_type(), 
      GetArenaForAllocation());
  }
  base_frame_moved_by_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    base_frame_moved_by_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_base_frame_moved_by()) {
    base_frame_moved_by_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_base_frame_moved_by(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_joint()) {
    joint_ = new ::abb::robot::Joint(*from.joint_);
  } else {
    joint_ = nullptr;
  }
  if (from._internal_has_base_frame()) {
    base_frame_ = new ::abb::robot::Pose(*from.base_frame_);
  } else {
    base_frame_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:abb.robot.Single)
}

inline void Single::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
base_frame_moved_by_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  base_frame_moved_by_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&joint_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&base_frame_) -
    reinterpret_cast<char*>(&joint_)) + sizeof(base_frame_));
}

Single::~Single() {
  // @@protoc_insertion_point(destructor:abb.robot.Single)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Single::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  base_frame_moved_by_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete joint_;
  if (this != internal_default_instance()) delete base_frame_;
}

void Single::ArenaDtor(void* object) {
  Single* _this = reinterpret_cast< Single* >(object);
  (void)_this;
}
void Single::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Single::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Single::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.Single)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      base_frame_moved_by_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(joint_ != nullptr);
      joint_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(base_frame_ != nullptr);
      base_frame_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Single::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.Single.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.Single.type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.Joint joint = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_joint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.Pose base_frame = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_base_frame(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string base_frame_moved_by = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_base_frame_moved_by();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.Single.base_frame_moved_by");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Single::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.Single)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Single.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Single.type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_type(), target);
  }

  // optional .abb.robot.Joint joint = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::joint(this), target, stream);
  }

  // optional .abb.robot.Pose base_frame = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::base_frame(this), target, stream);
  }

  // optional string base_frame_moved_by = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_base_frame_moved_by().data(), static_cast<int>(this->_internal_base_frame_moved_by().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Single.base_frame_moved_by");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_base_frame_moved_by(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.Single)
  return target;
}

size_t Single::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.Single)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

    // optional string base_frame_moved_by = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_base_frame_moved_by());
    }

    // optional .abb.robot.Joint joint = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *joint_);
    }

    // optional .abb.robot.Pose base_frame = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *base_frame_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Single::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Single::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Single::GetClassData() const { return &_class_data_; }

void Single::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Single *>(to)->MergeFrom(
      static_cast<const Single &>(from));
}


void Single::MergeFrom(const Single& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.Single)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_base_frame_moved_by(from._internal_base_frame_moved_by());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_joint()->::abb::robot::Joint::MergeFrom(from._internal_joint());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_base_frame()->::abb::robot::Pose::MergeFrom(from._internal_base_frame());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Single::CopyFrom(const Single& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.Single)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Single::IsInitialized() const {
  return true;
}

void Single::InternalSwap(Single* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &type_, lhs_arena,
      &other->type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &base_frame_moved_by_, lhs_arena,
      &other->base_frame_moved_by_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Single, base_frame_)
      + sizeof(Single::base_frame_)
      - PROTOBUF_FIELD_OFFSET(Single, joint_)>(
          reinterpret_cast<char*>(&joint_),
          reinterpret_cast<char*>(&other->joint_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Single::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[14]);
}

// ===================================================================

class Robot::_Internal {
 public:
  using HasBits = decltype(std::declval<Robot>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::robot::Pose& base_frame(const Robot* msg);
  static void set_has_base_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_base_frame_moved_by(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::abb::robot::Pose&
Robot::_Internal::base_frame(const Robot* msg) {
  return *msg->base_frame_;
}
Robot::Robot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  joints_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.Robot)
}
Robot::Robot(const Robot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      joints_(from.joints_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_type(), 
      GetArenaForAllocation());
  }
  base_frame_moved_by_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    base_frame_moved_by_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_base_frame_moved_by()) {
    base_frame_moved_by_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_base_frame_moved_by(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_base_frame()) {
    base_frame_ = new ::abb::robot::Pose(*from.base_frame_);
  } else {
    base_frame_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:abb.robot.Robot)
}

inline void Robot::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
base_frame_moved_by_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  base_frame_moved_by_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
base_frame_ = nullptr;
}

Robot::~Robot() {
  // @@protoc_insertion_point(destructor:abb.robot.Robot)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Robot::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  base_frame_moved_by_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete base_frame_;
}

void Robot::ArenaDtor(void* object) {
  Robot* _this = reinterpret_cast< Robot* >(object);
  (void)_this;
}
void Robot::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Robot::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Robot::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.Robot)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  joints_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      base_frame_moved_by_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(base_frame_ != nullptr);
      base_frame_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Robot::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.Robot.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.Robot.type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .abb.robot.Joint joints = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_joints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.Pose base_frame = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_base_frame(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string base_frame_moved_by = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_base_frame_moved_by();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.Robot.base_frame_moved_by");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Robot::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.Robot)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Robot.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Robot.type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_type(), target);
  }

  // repeated .abb.robot.Joint joints = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_joints_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_joints(i), target, stream);
  }

  // optional .abb.robot.Pose base_frame = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::base_frame(this), target, stream);
  }

  // optional string base_frame_moved_by = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_base_frame_moved_by().data(), static_cast<int>(this->_internal_base_frame_moved_by().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Robot.base_frame_moved_by");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_base_frame_moved_by(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.Robot)
  return target;
}

size_t Robot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.Robot)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .abb.robot.Joint joints = 3;
  total_size += 1UL * this->_internal_joints_size();
  for (const auto& msg : this->joints_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

    // optional string base_frame_moved_by = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_base_frame_moved_by());
    }

    // optional .abb.robot.Pose base_frame = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *base_frame_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Robot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Robot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Robot::GetClassData() const { return &_class_data_; }

void Robot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Robot *>(to)->MergeFrom(
      static_cast<const Robot &>(from));
}


void Robot::MergeFrom(const Robot& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.Robot)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  joints_.MergeFrom(from.joints_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_base_frame_moved_by(from._internal_base_frame_moved_by());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_base_frame()->::abb::robot::Pose::MergeFrom(from._internal_base_frame());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Robot::CopyFrom(const Robot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.Robot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Robot::IsInitialized() const {
  return true;
}

void Robot::InternalSwap(Robot* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  joints_.InternalSwap(&other->joints_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &type_, lhs_arena,
      &other->type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &base_frame_moved_by_, lhs_arena,
      &other->base_frame_moved_by_, rhs_arena
  );
  swap(base_frame_, other->base_frame_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Robot::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[15]);
}

// ===================================================================

class MechanicalUnit::_Internal {
 public:
  using HasBits = decltype(std::declval<MechanicalUnit>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::robot::Robot& robot(const MechanicalUnit* msg);
  static void set_has_robot(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_task_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_axes(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_axes_total(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_is_integrated_unit(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_has_integrated_unit(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

const ::abb::robot::Robot&
MechanicalUnit::_Internal::robot(const MechanicalUnit* msg) {
  return *msg->robot_;
}
MechanicalUnit::MechanicalUnit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  singles_(arena),
  standardized_joints_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.MechanicalUnit)
}
MechanicalUnit::MechanicalUnit(const MechanicalUnit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      singles_(from.singles_),
      standardized_joints_(from.standardized_joints_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  task_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    task_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_task_name()) {
    task_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_task_name(), 
      GetArenaForAllocation());
  }
  is_integrated_unit_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    is_integrated_unit_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_is_integrated_unit()) {
    is_integrated_unit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_is_integrated_unit(), 
      GetArenaForAllocation());
  }
  has_integrated_unit_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    has_integrated_unit_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_has_integrated_unit()) {
    has_integrated_unit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_has_integrated_unit(), 
      GetArenaForAllocation());
  }
  status_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_status(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_robot()) {
    robot_ = new ::abb::robot::Robot(*from.robot_);
  } else {
    robot_ = nullptr;
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&type_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.MechanicalUnit)
}

inline void MechanicalUnit::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
task_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  task_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
is_integrated_unit_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  is_integrated_unit_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
has_integrated_unit_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  has_integrated_unit_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
status_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&robot_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&robot_)) + sizeof(mode_));
}

MechanicalUnit::~MechanicalUnit() {
  // @@protoc_insertion_point(destructor:abb.robot.MechanicalUnit)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MechanicalUnit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  task_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  is_integrated_unit_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  has_integrated_unit_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  status_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete robot_;
}

void MechanicalUnit::ArenaDtor(void* object) {
  MechanicalUnit* _this = reinterpret_cast< MechanicalUnit* >(object);
  (void)_this;
}
void MechanicalUnit::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MechanicalUnit::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MechanicalUnit::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.MechanicalUnit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  singles_.Clear();
  standardized_joints_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      task_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      is_integrated_unit_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      has_integrated_unit_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      status_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(robot_ != nullptr);
      robot_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&axes_) -
        reinterpret_cast<char*>(&type_)) + sizeof(axes_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&axes_total_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&axes_total_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MechanicalUnit::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.MechanicalUnit.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.Robot robot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_robot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .abb.robot.Single singles = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_singles(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.MechanicalUnit.Type type = 4 [default = UNDEFINED];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::abb::robot::MechanicalUnit_Type_IsValid(val))) {
            _internal_set_type(static_cast<::abb::robot::MechanicalUnit_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string task_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_task_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.MechanicalUnit.task_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 axes = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_axes(&has_bits);
          axes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 axes_total = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_axes_total(&has_bits);
          axes_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string is_integrated_unit = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_is_integrated_unit();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.MechanicalUnit.is_integrated_unit");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string has_integrated_unit = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_has_integrated_unit();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.MechanicalUnit.has_integrated_unit");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string status = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_status();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.MechanicalUnit.status");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.MechanicalUnit.Mode mode = 11 [default = DEACTIVATED];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::abb::robot::MechanicalUnit_Mode_IsValid(val))) {
            _internal_set_mode(static_cast<::abb::robot::MechanicalUnit_Mode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(11, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .abb.robot.StandardizedJoint standardized_joints = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_standardized_joints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MechanicalUnit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.MechanicalUnit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.MechanicalUnit.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional .abb.robot.Robot robot = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::robot(this), target, stream);
  }

  // repeated .abb.robot.Single singles = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_singles_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_singles(i), target, stream);
  }

  // optional .abb.robot.MechanicalUnit.Type type = 4 [default = UNDEFINED];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_type(), target);
  }

  // optional string task_name = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_task_name().data(), static_cast<int>(this->_internal_task_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.MechanicalUnit.task_name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_task_name(), target);
  }

  // optional int32 axes = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_axes(), target);
  }

  // optional int32 axes_total = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_axes_total(), target);
  }

  // optional string is_integrated_unit = 8;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_is_integrated_unit().data(), static_cast<int>(this->_internal_is_integrated_unit().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.MechanicalUnit.is_integrated_unit");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_is_integrated_unit(), target);
  }

  // optional string has_integrated_unit = 9;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_has_integrated_unit().data(), static_cast<int>(this->_internal_has_integrated_unit().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.MechanicalUnit.has_integrated_unit");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_has_integrated_unit(), target);
  }

  // optional string status = 10;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.MechanicalUnit.status");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_status(), target);
  }

  // optional .abb.robot.MechanicalUnit.Mode mode = 11 [default = DEACTIVATED];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      11, this->_internal_mode(), target);
  }

  // repeated .abb.robot.StandardizedJoint standardized_joints = 12;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_standardized_joints_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, this->_internal_standardized_joints(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.MechanicalUnit)
  return target;
}

size_t MechanicalUnit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.MechanicalUnit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .abb.robot.Single singles = 3;
  total_size += 1UL * this->_internal_singles_size();
  for (const auto& msg : this->singles_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .abb.robot.StandardizedJoint standardized_joints = 12;
  total_size += 1UL * this->_internal_standardized_joints_size();
  for (const auto& msg : this->standardized_joints_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string task_name = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_task_name());
    }

    // optional string is_integrated_unit = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_is_integrated_unit());
    }

    // optional string has_integrated_unit = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_has_integrated_unit());
    }

    // optional string status = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_status());
    }

    // optional .abb.robot.Robot robot = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *robot_);
    }

    // optional .abb.robot.MechanicalUnit.Type type = 4 [default = UNDEFINED];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional int32 axes = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_axes());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int32 axes_total = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_axes_total());
    }

    // optional .abb.robot.MechanicalUnit.Mode mode = 11 [default = DEACTIVATED];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MechanicalUnit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MechanicalUnit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MechanicalUnit::GetClassData() const { return &_class_data_; }

void MechanicalUnit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MechanicalUnit *>(to)->MergeFrom(
      static_cast<const MechanicalUnit &>(from));
}


void MechanicalUnit::MergeFrom(const MechanicalUnit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.MechanicalUnit)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  singles_.MergeFrom(from.singles_);
  standardized_joints_.MergeFrom(from.standardized_joints_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_task_name(from._internal_task_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_is_integrated_unit(from._internal_is_integrated_unit());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_has_integrated_unit(from._internal_has_integrated_unit());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_status(from._internal_status());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_robot()->::abb::robot::Robot::MergeFrom(from._internal_robot());
    }
    if (cached_has_bits & 0x00000040u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000080u) {
      axes_ = from.axes_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      axes_total_ = from.axes_total_;
    }
    if (cached_has_bits & 0x00000200u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MechanicalUnit::CopyFrom(const MechanicalUnit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.MechanicalUnit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MechanicalUnit::IsInitialized() const {
  return true;
}

void MechanicalUnit::InternalSwap(MechanicalUnit* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  singles_.InternalSwap(&other->singles_);
  standardized_joints_.InternalSwap(&other->standardized_joints_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &task_name_, lhs_arena,
      &other->task_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &is_integrated_unit_, lhs_arena,
      &other->is_integrated_unit_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &has_integrated_unit_, lhs_arena,
      &other->has_integrated_unit_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &status_, lhs_arena,
      &other->status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MechanicalUnit, mode_)
      + sizeof(MechanicalUnit::mode_)
      - PROTOBUF_FIELD_OFFSET(MechanicalUnit, robot_)>(
          reinterpret_cast<char*>(&robot_),
          reinterpret_cast<char*>(&other->robot_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MechanicalUnit::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[16]);
}

// ===================================================================

class MechanicalUnitGroup::_Internal {
 public:
  using HasBits = decltype(std::declval<MechanicalUnitGroup>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::robot::MechanicalUnit& robot(const MechanicalUnitGroup* msg);
  static void set_has_robot(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::abb::robot::MechanicalUnit&
MechanicalUnitGroup::_Internal::robot(const MechanicalUnitGroup* msg) {
  return *msg->robot_;
}
MechanicalUnitGroup::MechanicalUnitGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  mechanical_units_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.MechanicalUnitGroup)
}
MechanicalUnitGroup::MechanicalUnitGroup(const MechanicalUnitGroup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      mechanical_units_(from.mechanical_units_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_robot()) {
    robot_ = new ::abb::robot::MechanicalUnit(*from.robot_);
  } else {
    robot_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:abb.robot.MechanicalUnitGroup)
}

inline void MechanicalUnitGroup::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
robot_ = nullptr;
}

MechanicalUnitGroup::~MechanicalUnitGroup() {
  // @@protoc_insertion_point(destructor:abb.robot.MechanicalUnitGroup)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MechanicalUnitGroup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete robot_;
}

void MechanicalUnitGroup::ArenaDtor(void* object) {
  MechanicalUnitGroup* _this = reinterpret_cast< MechanicalUnitGroup* >(object);
  (void)_this;
}
void MechanicalUnitGroup::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MechanicalUnitGroup::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MechanicalUnitGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.MechanicalUnitGroup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mechanical_units_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(robot_ != nullptr);
      robot_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MechanicalUnitGroup::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.MechanicalUnitGroup.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.MechanicalUnit robot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_robot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .abb.robot.MechanicalUnit mechanical_units = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_mechanical_units(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MechanicalUnitGroup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.MechanicalUnitGroup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.MechanicalUnitGroup.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional .abb.robot.MechanicalUnit robot = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::robot(this), target, stream);
  }

  // repeated .abb.robot.MechanicalUnit mechanical_units = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_mechanical_units_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_mechanical_units(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.MechanicalUnitGroup)
  return target;
}

size_t MechanicalUnitGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.MechanicalUnitGroup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .abb.robot.MechanicalUnit mechanical_units = 3;
  total_size += 1UL * this->_internal_mechanical_units_size();
  for (const auto& msg : this->mechanical_units_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .abb.robot.MechanicalUnit robot = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *robot_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MechanicalUnitGroup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MechanicalUnitGroup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MechanicalUnitGroup::GetClassData() const { return &_class_data_; }

void MechanicalUnitGroup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MechanicalUnitGroup *>(to)->MergeFrom(
      static_cast<const MechanicalUnitGroup &>(from));
}


void MechanicalUnitGroup::MergeFrom(const MechanicalUnitGroup& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.MechanicalUnitGroup)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  mechanical_units_.MergeFrom(from.mechanical_units_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_robot()->::abb::robot::MechanicalUnit::MergeFrom(from._internal_robot());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MechanicalUnitGroup::CopyFrom(const MechanicalUnitGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.MechanicalUnitGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MechanicalUnitGroup::IsInitialized() const {
  return true;
}

void MechanicalUnitGroup::InternalSwap(MechanicalUnitGroup* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  mechanical_units_.InternalSwap(&other->mechanical_units_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(robot_, other->robot_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MechanicalUnitGroup::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[17]);
}

// ===================================================================

class RAPIDModule::_Internal {
 public:
  using HasBits = decltype(std::declval<RAPIDModule>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

RAPIDModule::RAPIDModule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.RAPIDModule)
}
RAPIDModule::RAPIDModule(const RAPIDModule& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_type(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:abb.robot.RAPIDModule)
}

inline void RAPIDModule::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RAPIDModule::~RAPIDModule() {
  // @@protoc_insertion_point(destructor:abb.robot.RAPIDModule)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RAPIDModule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void RAPIDModule::ArenaDtor(void* object) {
  RAPIDModule* _this = reinterpret_cast< RAPIDModule* >(object);
  (void)_this;
}
void RAPIDModule::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RAPIDModule::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RAPIDModule::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.RAPIDModule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      type_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RAPIDModule::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.RAPIDModule.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.RAPIDModule.type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RAPIDModule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.RAPIDModule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.RAPIDModule.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.RAPIDModule.type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.RAPIDModule)
  return target;
}

size_t RAPIDModule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.RAPIDModule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RAPIDModule::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RAPIDModule::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RAPIDModule::GetClassData() const { return &_class_data_; }

void RAPIDModule::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RAPIDModule *>(to)->MergeFrom(
      static_cast<const RAPIDModule &>(from));
}


void RAPIDModule::MergeFrom(const RAPIDModule& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.RAPIDModule)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_type(from._internal_type());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RAPIDModule::CopyFrom(const RAPIDModule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.RAPIDModule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RAPIDModule::IsInitialized() const {
  return true;
}

void RAPIDModule::InternalSwap(RAPIDModule* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &type_, lhs_arena,
      &other->type_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata RAPIDModule::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[18]);
}

// ===================================================================

class RAPIDTask::_Internal {
 public:
  using HasBits = decltype(std::declval<RAPIDTask>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_motion_task(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_active(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_execution_state(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

RAPIDTask::RAPIDTask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  modules_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:abb.robot.RAPIDTask)
}
RAPIDTask::RAPIDTask(const RAPIDTask& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      modules_(from.modules_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&is_motion_task_, &from.is_motion_task_,
    static_cast<size_t>(reinterpret_cast<char*>(&execution_state_) -
    reinterpret_cast<char*>(&is_motion_task_)) + sizeof(execution_state_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.RAPIDTask)
}

inline void RAPIDTask::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&is_motion_task_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_active_) -
    reinterpret_cast<char*>(&is_motion_task_)) + sizeof(is_active_));
execution_state_ = 1;
}

RAPIDTask::~RAPIDTask() {
  // @@protoc_insertion_point(destructor:abb.robot.RAPIDTask)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RAPIDTask::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void RAPIDTask::ArenaDtor(void* object) {
  RAPIDTask* _this = reinterpret_cast< RAPIDTask* >(object);
  (void)_this;
}
void RAPIDTask::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RAPIDTask::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RAPIDTask::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.RAPIDTask)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  modules_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  ::memset(&is_motion_task_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_active_) -
      reinterpret_cast<char*>(&is_motion_task_)) + sizeof(is_active_));
  execution_state_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RAPIDTask::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "abb.robot.RAPIDTask.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_motion_task = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_motion_task(&has_bits);
          is_motion_task_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_active = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_active(&has_bits);
          is_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.RAPIDTask.ExecutionState execution_state = 4 [default = UNKNOWN];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::abb::robot::RAPIDTask_ExecutionState_IsValid(val))) {
            _internal_set_execution_state(static_cast<::abb::robot::RAPIDTask_ExecutionState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .abb.robot.RAPIDModule modules = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_modules(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RAPIDTask::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.RAPIDTask)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.RAPIDTask.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bool is_motion_task = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_is_motion_task(), target);
  }

  // optional bool is_active = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_is_active(), target);
  }

  // optional .abb.robot.RAPIDTask.ExecutionState execution_state = 4 [default = UNKNOWN];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_execution_state(), target);
  }

  // repeated .abb.robot.RAPIDModule modules = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_modules_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_modules(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.RAPIDTask)
  return target;
}

size_t RAPIDTask::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.RAPIDTask)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .abb.robot.RAPIDModule modules = 5;
  total_size += 1UL * this->_internal_modules_size();
  for (const auto& msg : this->modules_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional bool is_motion_task = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool is_active = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional .abb.robot.RAPIDTask.ExecutionState execution_state = 4 [default = UNKNOWN];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_execution_state());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RAPIDTask::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RAPIDTask::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RAPIDTask::GetClassData() const { return &_class_data_; }

void RAPIDTask::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RAPIDTask *>(to)->MergeFrom(
      static_cast<const RAPIDTask &>(from));
}


void RAPIDTask::MergeFrom(const RAPIDTask& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.RAPIDTask)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  modules_.MergeFrom(from.modules_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      is_motion_task_ = from.is_motion_task_;
    }
    if (cached_has_bits & 0x00000004u) {
      is_active_ = from.is_active_;
    }
    if (cached_has_bits & 0x00000008u) {
      execution_state_ = from.execution_state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RAPIDTask::CopyFrom(const RAPIDTask& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.RAPIDTask)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RAPIDTask::IsInitialized() const {
  return true;
}

void RAPIDTask::InternalSwap(RAPIDTask* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  modules_.InternalSwap(&other->modules_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RAPIDTask, is_active_)
      + sizeof(RAPIDTask::is_active_)
      - PROTOBUF_FIELD_OFFSET(RAPIDTask, is_motion_task_)>(
          reinterpret_cast<char*>(&is_motion_task_),
          reinterpret_cast<char*>(&other->is_motion_task_));
  swap(execution_state_, other->execution_state_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RAPIDTask::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[19]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace robot
}  // namespace abb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::abb::robot::Header* Arena::CreateMaybeMessage< ::abb::robot::Header >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::Header >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::RobotControllerDescription* Arena::CreateMaybeMessage< ::abb::robot::RobotControllerDescription >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::RobotControllerDescription >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::RobotWareVersion* Arena::CreateMaybeMessage< ::abb::robot::RobotWareVersion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::RobotWareVersion >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::Cartesian* Arena::CreateMaybeMessage< ::abb::robot::Cartesian >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::Cartesian >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::Quaternion* Arena::CreateMaybeMessage< ::abb::robot::Quaternion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::Quaternion >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::Pose* Arena::CreateMaybeMessage< ::abb::robot::Pose >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::Pose >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::RobotIndicators* Arena::CreateMaybeMessage< ::abb::robot::RobotIndicators >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::RobotIndicators >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::OptionIndicators* Arena::CreateMaybeMessage< ::abb::robot::OptionIndicators >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::OptionIndicators >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::AddInIndicators* Arena::CreateMaybeMessage< ::abb::robot::AddInIndicators >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::AddInIndicators >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::SystemIndicators* Arena::CreateMaybeMessage< ::abb::robot::SystemIndicators >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::SystemIndicators >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::Transmission* Arena::CreateMaybeMessage< ::abb::robot::Transmission >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::Transmission >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::Arm* Arena::CreateMaybeMessage< ::abb::robot::Arm >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::Arm >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::Joint* Arena::CreateMaybeMessage< ::abb::robot::Joint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::Joint >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::StandardizedJoint* Arena::CreateMaybeMessage< ::abb::robot::StandardizedJoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::StandardizedJoint >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::Single* Arena::CreateMaybeMessage< ::abb::robot::Single >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::Single >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::Robot* Arena::CreateMaybeMessage< ::abb::robot::Robot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::Robot >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::MechanicalUnit* Arena::CreateMaybeMessage< ::abb::robot::MechanicalUnit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::MechanicalUnit >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::MechanicalUnitGroup* Arena::CreateMaybeMessage< ::abb::robot::MechanicalUnitGroup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::MechanicalUnitGroup >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::RAPIDModule* Arena::CreateMaybeMessage< ::abb::robot::RAPIDModule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::RAPIDModule >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::RAPIDTask* Arena::CreateMaybeMessage< ::abb::robot::RAPIDTask >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::RAPIDTask >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
